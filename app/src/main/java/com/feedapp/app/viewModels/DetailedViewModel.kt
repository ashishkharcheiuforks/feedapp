package com.feedapp.app.viewModelsimport android.util.Logimport androidx.lifecycle.*import com.feedapp.app.data.api.models.usdafooddetailed.USDAFoodModelimport com.feedapp.app.data.exceptions.NoInternetConnectionExceptionimport com.feedapp.app.data.models.ConverterToProductimport com.feedapp.app.data.models.FoodProductimport com.feedapp.app.data.models.RecentProductimport com.feedapp.app.data.models.day.DayDateimport com.feedapp.app.data.repositories.DayRepositoryimport com.feedapp.app.data.repositories.SearchFoodRepositoryimport com.feedapp.app.data.repositories.UserRepositoryimport com.feedapp.app.util.TAGimport io.reactivex.schedulers.Schedulersimport kotlinx.coroutines.Dispatchersimport kotlinx.coroutines.launchimport javax.inject.Injectclass DetailedViewModel @Inject constructor(    private val searchRepository: SearchFoodRepository,    private val dayRepository: DayRepository,    private val userRepository: UserRepository) : ViewModel() {    private val foodMediator = MediatorLiveData<USDAFoodModel>()    val multiplier = MutableLiveData<Double>(1.0)    val isConnected = MutableLiveData<Boolean>(true)    // 0 - grams' position in array of list by default    val multiplierPosition = MutableLiveData(0)    val isSearching = MutableLiveData<Boolean>(false)    val foodInfoOnline = MutableLiveData<USDAFoodModel>()    val foodInfoOffline = MutableLiveData<FoodProduct>()    /*        load Detailed information about product from API     */    fun getInfoAboutProduct(id: Int) {        if (isConnected.value == true) {            try {                val source = LiveDataReactiveStreams.fromPublisher(                    searchRepository.getInfoAboutProduct(id)!!                        .doOnError { e -> e.printStackTrace() }                        .subscribeOn(Schedulers.io())                        .doOnComplete { isSearching.postValue(false) }                )                foodMediator.addSource(source) {                    foodMediator.postValue(it)                    foodMediator.removeSource(source)                }            } catch (e: NoInternetConnectionException) {                e.printStackTrace()            } catch (e: Exception) {                isSearching.postValue(false)                Log.e(TAG, "Failed accessing API...")                e.printStackTrace()            }        } else {            // todo: make dialog callback            val usdaFoodModel = USDAFoodModel()            foodInfoOnline.postValue(usdaFoodModel)        }    }    /*        search product in offline DB    */    fun searchFoodProduct(title: String, id: Int? = null) =        viewModelScope.launch(Dispatchers.IO) {            // if id supplied, search by id, otherwise by title            val product = if (id != null) {                searchRepository.searchOffline(id)            } else {                searchRepository.searchOfflineByExactName(title)            }            product?.let {                foodInfoOffline.postValue(product)            }        }    fun searchFoodProduct(id: Int) =        viewModelScope.launch(Dispatchers.IO) {            val product = searchRepository.searchOffline(id)            product?.let {                foodInfoOffline.postValue(product)            }        }    fun isMultiplierValueValid(text: String): Boolean {        return !(text.toDouble() > 100 && (multiplierPosition.value != 0))    }    fun canSave(): Boolean {        return isSearching.value == false    }    fun saveConsumedFoodToDB(        dateString: DayDate?,        mealType: Int?,        grams: Float    ) =        viewModelScope.launch(Dispatchers.IO) {            if (dateString == null || mealType == null) return@launch            // save to consumed Products to the specific date            dayRepository.saveSearchProductToDay(                dateString,                mealType,                foodInfoOnline.value,                foodInfoOffline.value,                grams            )            // save to recent products            foodInfoOnline.value?.let {                val recentProduct = RecentProduct(                    product = ConverterToProduct().convertUSDAModel(it, 0f),                    recentFdcId = it.fdcId ?: 0                )                userRepository.saveToRecent(recentProduct)            }        }    fun observeFoodInfo(): MediatorLiveData<USDAFoodModel> {        return foodMediator    }}